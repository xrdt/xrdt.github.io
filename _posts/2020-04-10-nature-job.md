---
layout: posts
title: "Nature of a Job"
---
*Author: Bianca Yang*<br>
*Email: <a href="mailto:ipacifics@gmail.com?subject=Hello from the XDRT Blog">ipacifics@gmail.com</a>*<br>

Today's post is maybe banal, maybe obvious, and maybe just plain wrong,
but sometimes banal, obvious, and stupid things need to be said out loud before
they can be understood and corrected:
> The nature of your job doesn't change between companies.

A programming job is a programming job is a programming job, no matter whether
you're working at Google or a basement startup or some GDS with IBM mainframes
from the 60s. Your fundamental objective is to write code that does something
useful for the company. Yada yada, there are bullshit jobs and sometimes you
don't get to use your language of choice and maybe the IT department is a
total mess or nonexistent and getting simple resources provisioned is near
impossible, but still, your job is to write code that solves some problems that
someone (may not be, probably isn't you) decided is worth regularly sending you
a paycheck to solve.

What differs between jobs is the following things:
* Equipment
* Processes and Structure of the Bureaucracy
* People / Culture
* Pay
* Location
* Expectations in terms of productivity and hours
* Technology stack
* Perks (food, insurance, bonuses, sabbaticals)
* Whether the CEO is a balding (or already bald) white male

None of the above things changes the fundamental task of you being paid to sit
at some workstation and type on some keys until some computer somewhere does
what people above you want it to do. Yes, the things above can make it harder
or easier to do your job. The things above can make you more or less inclined
to do your job. The things above can make you enjoy or hate your job. The things
above can affect whether you'll have a job in the future. But the fundamental
activity, which is writing code and debugging it and getting it into
production, is the same at every company. If you just don't like
writing code and debugging it and thinking about the limits of what computers
can compute and making your code more efficient and deployment pipelines and
networking and all the other things that fall under the wonderful title of
software engineering, your basic satisfaction with a job as a software engineer
cannot exceed some minimum level of satisfaction that gets you to do enough work
to not be fired. And that's a tough position to be in.
